const mf = require('./fix_func');
/* 원래 코드 */
// // 배열에 들어있는 값 중 하나라도 긍정적인 값이 있으면 true, 아니면 false
// function some(list) {
//     return not(not(positive(list)));
// }
//
// // 배열에 들어있는 모든 값이 긍정이면 true, 아니면 false
// function every(list) {
//     return beq(-1)(negativeIndex(list));
// }

function some() {
    return compose(not, not, positive);
}

function every() {
    return compose(beq(-1), negativeIndex);
}

/*
    compose로 some과 every를 더 간결하게 표현했다. 주석으로 표시해 둔 원래코드와 동일하게 동작한다.
맨 오른족의 함수가 인자를 받아 결과를 만들고 결과는 다시 그 왼쪽의 함수에게 인자로 전달된다.
오른쪽에서부터 왼쪽으로 연속적으로 실행되어 최종 결과를 만든다.
    값 대신 함수로, for와 if 대신 고차 함수와 보조 함수로, 연산자 대신 함수로, 함수 합성 등 앞서 설명한
함수적 기법들을 사용하면 코드도 간결해지고 함수명을 통해 로직을 더 명확히 전달할 수 있어 읽기 좋은 코드가 된다.
    짧고 읽기 좋은 코드도 중요한 가치이지만 좀 더 고상한 이점이 있다. 인자 선언이나 변수 선언이 적어진다는 점이다.
코드에 인자와 변수가 등장하지 않고 함수의 내부({statements})가 보이지 않는다는 것은 새로운 상황도 생기지 않는다는 말이다.
새로운 상황이 생기지 않는다는 것은 개발자가 예측하지 못할 상황이 없다는 말이다. 에러 없는 함수들이 인자와 결과에 맞게 잘 조합되어
있다면 전체의 결과 역시 에러가 날 수 있다. 상태를 공유하지 않는 작은 단위의 함수들은 테스트하기도 쉽고 테스트 케이스를 작성하기도 쉽다.
    대규모 애플리케이션을 개발하다보면 새로운 요구사항을 반영하거나버그를 잡거나 성능을 높이기 위해 이미 완성되었던 코드를 고쳐야 할 때가
많다. 배포된지 시간이 좀 지난 코드라면 자신이 작성한 코드일지라도 그 내용이 어림짐작만 될 뿐 아주 익숙하지 않을 것이다. 만일 지역 변수와
if문이 많고 중간에 for문도 몇 번 나오고, j++도 있으며 push 등으로 상태를 변경하는 코드라면, 당시 고려했던 모든 상황들을 다시 머릿속에
그리기 어렵다. 코드 윗부분에서 선언된 지역변수가 특정 부분의 if문 안쪽에서 사용되고, 중간에 값이 변경된 다음, 그 아래 어딘가의 if문에서
또 사용된다면 어느 부분이 망가질지 몰라 선뜻 손대기가 어렵다.
    만일 지역 변수도 없고 if, else, for문도 없고, 커스텀 객체의 메서드도 없고, 인자 외의 외부 상태에 의존하고 잇지 않다면,
자신이 고쳐야 하는 함수의 문제에만 집중할 수 있다. 인자와 변수 자체가 적을수록, 함수의 {statements}가 없거나 짧을수록, 함수들의 복잡성
도 줄어들고 오류가 생길 가능성도 줄어들며 부수 효과도 줄어든다. 또한 작성한 지 오래된 코드일지라도 다시 읽고 고치기가 쉬워진다.
함수 하나하나가 무슨 일을 하는지에 대해 인자와 결과 위주로만 생각하면서 읽고 고치면 되기 때문이다.
    작게 쪼개다 보면 정말 쓸모 없어 보이는 함수가 많이 나오기도 한다. 그래도 더 작은 단위로 쪼개 보라, 재사용성이 높고 재밌는 코드들이
나올 것이다. 제어문 대신 함수를, 값 대신 함수를, 연산자 대신 함수를 사용해보자. 프로글매ㅣㅇ에 대한 새롭고 재밌는 아이디어들을 만나게 될
것이다.
*/
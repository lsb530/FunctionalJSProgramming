1.2.1 회원 목록 중 여러명 찾기
    코드1-5. for문으로 필터링하기
1.2.2 for문에서 filter로, if에서 predicate로
    코드1-6. filter
    코드1-7. filter사용
1.2.3 함수형 프로그래밍 관점으로 filter보기
    filter 함수에는 for도 있고 if도 있지만, filter 함수는 항상 동일하게 동작하는 함수이다.
    한 가지 로직을 가졌다는 뜻이다. 동일한 인자가 들어오면 항상 동일하게 동작한다.
    filter 함수의 로직은 외부나 내부의 어떤 상태 변화에도 의존하지 않는다.
    > 절차지향 프로그래밍에서는 위에서 아래로 내려가면서 특정 변수의 값을 변경해 나가는 식으로 로직을 만든다.
    > 객체지향 프로그래밍에서는 객체들을 만들어 놓고 객체들 간의 협업을 통해 로직을 만든다.
      이벤트 등으로 서로를 연결한후 상태의 변화를 감지하여 스스로 자신이 가진 값을 변경하거나, 상대의 메서드를 직접 실행하여
      상태를 변경하는 식으로 프로그래밍을 한다.
    > 함수형 프로그래밍에서는 '항상 동일하게 동작하는 함수'를 만들고 보조 함수를 조합하는 식으로 로직을 완성한다.
      내부에서 관리하고 있는 상태를 따로 두지 않고 넘겨진 인자에만 의존한다. 동일한 인자가 들어오면 항상 동일한 값을 리턴하도록 한다.
      보조 함수 역시 인자이며, 보조 함수에서도 상태를 변경하지 않으면 보조 함수를 받은 함수는 항상 동일한 결과를 만드는 함수가 된다.
1.2.4 map 함수
1.2.5 실행 결과로 바로 실행하기
    함수의 리턴값을 바로 다른 함수의 인자로 사용하면 변수 할당을 줄일 수 있다. filter 함수의 결과가 배열이므로 map의 첫번째 인자로
    바로 사용 가능하다.
    코드 1-10. 함수 중첩
    코드 1-11. 함수 중첩2
    코드 1-12. filter, map
1.2.6 함수를 값으로 다룬 예제의 실용성
    1.1절에서 소개했던 addMaker와 비슷한 패턴의 함수가 실제로도 많이 사용된다. addMaker와 비슷한 패턴의 함수인 bvalue 함수를 만들면
    코드 1-12의 코드를 더 줄일 수 있다.
    코드 1-13. 함수를리턴하는 함수 bvalue
    코드 1-14. bvalue로 map의 iteratee 만들기
    코드 1-15. 화살표 함수와 함께 사용하기
1.3 함수형 자바스크립트의 실용성 2
1.3.1 회원 목록 중 한 명 찾기
    코드 1-16. filter로 한 명 찾기
    코드 1-17. break문
    코드 1-18. findById
    코드 1-19. findByName
    코드 1-20. findByAge
    코드 1-21. findBy
    코드 1-22. findBy로 안되는 경우
1.3.2 값에서 함수로
    코드 1-23. find
    코드 1-24. 다형성
1.3.3 함수를 만드는 함수와 find, filter 조합하기
    코드 1-25. bmatch1로 predicate 만들기
    코드 1-26. bmatch1로 함수를 만들어 고차함수와 협업
    코드 1-27. bmatch
    코드 1-28. findIndex
1.3.4 고차함수
    앞서 구현했던 map, filter, find, findIndex, bvalue, bmatch와 같은 함수들은 모두 고차함수이다.
    고차함수란? 함수를 인자로 받거나 함수를 리턴하는 함수. 당연히 둘 다 하는 함수도 고차함수이다.
    보통 고차함수는 함수를 인자로 받아 필요한 떄에 실행하거나 클로저를 만들어 리턴한다.
    앞서 만든 map, filter, find, findIndex는 Underscore.js에도 있는 함수들이다.
    Underscore.js는 Gibhub 별이 20,000개가 넘는 유명한 함수형 자바스크립트 라이브러리이다.
    Underscore.js의 .map, _.filter, _.find, _.findIndex는 iteratee와 predicate가 사용할 인자를
    몇 가지 더 제공한다. 재료가 많으면 더 다양한 로직을 만들 수 있다. map, filter, find, findIndex를 Underscore.js의
    _.map, _.filter, _.find, _.findIndex에 가깝게 좀 더 고쳐보자
    코드 1-29. 인자 늘리기
    코드 1-30. predicate에서 두 번째 인자 사용하기
1.3.5 function identity(v) { return v; }, 이건 어디다 쓰는거지?
    코드 1-31. identity
    코드 1-32. predicate로 identity를 사용한 경우
    코드 1-33. some, every
1.3.6 연산자 대신 함수로
    코드 1-34. 아주 작은 함수 not, beq
    코드 1-35. some, every 만들기2
1.3.7 함수 합성
    함수를 쪼갤수록 함수 합성은 쉬워진다.
    코드 1-36. 함수 쪼개기
    코드 1-37. compose
    코드 1-38. compose로 함수 합성하기
1.4 함수형 자바스크립트를 위한 기초
    함수형 자바스크립트를 잘 익히기 위해서는 함수를 실행하는 법이나 유명한 함수의 사용법 등을 익히는 것도 중요하지만 무엇보다 함수를
다루는 다양한 방법들을 잘 익히는 것이 중요하다. 함수를 잘 다루려면 함수와 관련된 개념들과 관련된 몇 가지 기능들에 대해 잘 알아야 하는데
이를테면 일급 함수, 클로져, 고차함수, 콜백 패턴, 부분 적용, arguments 객체 다루기, 함수 객체의 메서드(bind, call, apply)등이 있다.
    함수의 다양한 기능을 알고 있다면 복잡한 로직이나 기능을 더욱 효과적으로 구현할 수 있다. jQuery를 개발한 존 레식(John Resig)의
저서 [자바스크립트 닌자 비급]에서는 함수에 대한 이해도가 높아야 닌자(고수)의 코드를 작성할 수 있다고 했다.
    물론 함수에 대해 잘 몰라도 소프트웨어를 완성할 수 있다. 그러나 앞서 말한 기능이나 개념들에 대한 이해도는 소프트웨어의 완성도나 코드
스타일에 있어 분명한 차이를 만들며, 이후 운영이나 기획 변경에 대한 대응책에 있어서도 차이를 만든다. 더 나아가 사용자 경험에도 영향을 끼칠
수 있다고 생각한다.
1.4.1 일급 함수
    '일급'(값으로 다룰 수 있음) 이 되기 위한 조건 3가지
        - 변수에 담을 수 있다
        - 함수나 메서드의 인자로 넘길 수 있다
        - 함수나 메서드에서 리턴할 수 있다
    '일급함수'가 되기 위한 추가 조건 3가지
        - 아무 때나(런타임에서도) 선언이 가능하다
        - 익명으로 선언할 수 있다
        - 익명으로 선언한 함수도 함수나 메서드의 인자로 넘길 수 있다
    자바스크립트의함수는 위 조건을 모두 만족하는 일급 함수다
    코드 1-39. 일급함수
    코드 1-40. 클로저
    